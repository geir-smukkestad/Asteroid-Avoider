Create new project - 2D URP
Package manager:
	- Input system (click Yes when asked to enable)
Game view -> Simulator

Simulate touch input:
	- Window -> Analysis -> Input debugger: 
		Options -> Simulate touch input from mouse or pen
Download asset from Unity Store:
	- Star Sparrow Modular Spaceship
	- Click "Open in unity" after adding asset
	- Download it in package manager
	- Import -> Uncheck Readme, Scenes and Substance Painter
	- Look at materials, they're all pink. Need to be converted to URP
		- Edit -> Rendering -> Materials -> Convert built-in materials to URP
		
Processing input:
	- Set up camera:
		- Reset transformation
		- Orthographic
		
Player:
	- Empty object - Player. Reset transformation.
	- Drag in Sparrow1 prefab as a child
	- Change camera Z position to -10 in order to look at the player at (0,0,0)
	- Rotate -90 around X axis in order to see ship from the top in 2D
	- Scale by 0.1

Change background:
	- On main camera -> Environment:
		- Type: Solid colour
		
Processing input:
	- New script, PlayerMovement
	- Attach to Player
	- Check if we're touching the screen:
	
        if (Touchscreen.current.primaryTouch.press.isPressed)
        {
            Vector2 touchPos = Touchscreen.current.primaryTouch.position.ReadValue();
            Debug.Log(touchPos);

            Vector3 worldPosition = m_mainCamera.ScreenToWorldPoint(touchPos);
            Debug.Log(worldPosition);            
        }
		
		or 
		
		using UnityEngine.InputSystem.EnhancedTouch;
		using Touch = UnityEngine.InputSystem.EnhancedTouch.Touch;

        if (Touch.activeTouches.Count > 0)
        {
            Debug.Log(Touch.activeTouches[0].screenPosition);
            Vector3 worldPosition = m_mainCamera.ScreenToWorldPoint(Touch.activeTouches[0].screenPosition);
            Debug.Log(worldPosition);
        }
		
Spaceship movement:
	- Add RigidBody. Uncheck "use gravity"
	- Get ref to RigidBody in script:
		- m_rigidBody = GetComponent<Rigidbody>();
	- Update: Set m_movementDirection based on touch input
	- FixedUpdate: Add force:
		m_rigidBody.AddForce(m_movementDirection * m_forceMagnitude, ForceMode.Force);
	
Screen wraparound:
	- Vector3 viewportPos = m_mainCamera.WorldToViewportPoint(transform.position);
        if (viewportPos.x > 1)
            newPosition.x = -newPosition.x + 0.1f;

Spaceship rotation
	- Rotate according to velocity vector:
        Quaternion targetRotation = Quaternion.LookRotation(m_rigidBody.velocity, Vector3.back);
        transform.rotation = Quaternion.Lerp(transform.rotation, targetRotation, m_rotationSpeed * Time.deltaTime);

Asteroids
	- Get red asteroid prefab from downloaded asset
		- Insert and prefab into our own prefabs (keep original)
		- Delete collider that comes with the asset
		- Add capsule collider, trigger
		- Add RigidBody, no gravity
	- Add scripts, Asteroid and PlayerHealth
	- On Player prefab:
		- Remove all colliders
		- Add mesh collider, convex, trigger
	- Get blue asteroid prefab.
		- Prefab into our own prefabs (keep original)
		- Delete collider, add sphere collider

Starfield
	- Effects -> Particle System
	- Place left of camera
	- Shape: Box, scale Y, randomize direction
	- Emission
	- Start 
	- Check "Prewarm" so that it fill the screen from the start
	
Asteroid spawner
	- New script and game object, AsteroidSpawner
	
		GameObject asteroidInstance = Instantiate(selectedAsteroid, worldSpawnPoint, Quaternion.Euler(0, 0, Random.Range(0, 360)));

	- Destroy asteroid when it leaves the screen: OnBecameInvisible
	
Game Over
	- Create new Scene, MainMenu, by duplicating the current one
	- Create empty game object, MainMenu
	- Create child canvas. Scale with screen size
	- Add title text
		- Anchor top (press shift + alt)
		- Increase font size
		- Increase Rect Transform Y
		- Center it
	- New button (Start Game). Anchor from bottom
	- Build settings: Make sure both scenes are in the list
	- New script, MainMenu
		public void StartGame()
		{
			SceneManager.LoadScene(1);
		}	
	- Connect play button with StartGame function
	- Click on EventSystem object: Click replace with InputSystemUIInputModule
	- Activate Game scene:
		- New game object: GameOverHandler
		- Add child canvas. Scale with screen size
		- Add image (UI -> Image).
			- Set image anchors to cover most of the screen. Reset rect.
		- Create child of image of background image.
			- Set anchor preset: Stretch
			- Adjust left, top, right, bottom to set margin against owner image
		- Create text
		
	- New script: GameOverHandler. Methods for play again and return to menu
	- Deactivate canvas, it's only to be displayed when the game ends
		- GameOverHandler: EndGame
		
Score system:
	- New game object: ScoreSystem'
	- Create child canvas. Scale with screen size
		- Graphic Raycaster can be removed, since we're not interacting with the canvas
		- Add text
		- Align at top: Anchors - shift+alt click top
	- New script: ScoreSystem
	
		void Update()
		{
			m_score += Time.deltaTime * m_scoreMultiplier;
			m_scoreText.text = Mathf.FloorToInt(m_score).ToString();
		}	
		
	- Make sure score count stops when game is over
        m_scoreSystem.OnEndGame();
		
	- Display score:
        m_gameOverText.text = $"GAME OVER\nScore: {m_scoreSystem.GetScore()}";        
		